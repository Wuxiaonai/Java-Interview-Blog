![](https://img.hacpai.com/bing/20180803.jpg?imageView2/1/w/960/h/520/interlace/1/q/100) 

## 前言
  本文作为MySQL个人进阶学习的第一篇文章，主要是用来介绍MySQL的整体结构，后续会对每一个部分进行讨论的细化。
  
## 数据库和数据库实例  
  在开始这篇文章之前，首先要说一下什么是数据库，什么是数据库实例。
  
  数据库指的是物理操作系统文件或其他形式文件类型的集合。是按照某种数据模型组织起来的并以二进制存储的数据集合。在MySQL数据库中，这些文件可以是frm、MYD、ibd结尾的文件，当使用NDB引擎时，数据库的文件可能不是操作系统上的文件，而是存放于内存之中的文件，但是定义仍旧是不变的。

  数据库实例是应用程序,由后台线程以及一个共享内存区组成的。是位于用户与操作系统之间的一层数据管理软件，用户对数据库进行操作，包括定义表结构，数据查询，数据维护等控制，都是在数据库实例下进行的，可以这样理解，应用程序通过数据库实例才能和数据库打交道。
  
 这两个词是非常容易被混淆的，在 MySQL 中，实例和数据库往往都是`一一对应`的，而我们也无法直接操作数据库，而是要通过数据库实例来操作数据库文件，可以理解为数据库实例是数据库为上层提供的一个专门用于操作的接口。

![imagepng](http://piv1n6e1j.bkt.clouddn.com//file/2018/11/4250d9ee6503410db9acf9a333cb09fc_image.png) 
在Windows系统上，启动一个MySQL实例只会产生一个进程。而在 Linux系统上，启动一个 MySQL 实例往往会产生两个进程--`mysqld`和`mysqld-safe`。`mysqld` 就是真正的数据库服务守护进程，而 `mysqld_safe` 是一个用于检查和设置 `mysqld` 启动的控制程序，它负责监控 MySQL 进程的执行，当 `mysqld` 发生错误时，`mysqld_safe` 会对其状态进行检查并在合适的条件下重启。



## MySQL数据库体系结构

### 初始MySQL组成
![MySQL架构图](https://static.oschina.net/uploads/space/2018/0318/163959_8MmT_2885163.png) 

上图为MySQL数据库的体系结构，由上图可见MySQL数据库分为以下几个组成部分：

* 连接器（Connectors）
* 连接池组件（Connection Pool)
* 企业级管理服务和工具组件（Enterprise Management Services &  Utilities)
* SQL 接口组建（SQL Interface)
* 查询分析器组件（Parser）
* 优化器组件（Optimizer）
* 缓冲组件（Caches&Buffer）
* 可插拔存储引擎（Pluggable Storage Engines）
* 文件系统中的存储数据（File&Logs）

### 组成部分详解
MySQL由那么多的组成部分，那么各个部分都有着什么作用呢？

1.**连接层**

最上层是一些客户端和连接服务，包含本地socket通信和大多数基于C/S工具实现的类似于tcp/ip的通信，主要完成一些类似于连接处理，授权认证及相关的安全方案。在该层上引入了线程池的概念，为了通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接，服务器也会为安全接入的每个客户端验证它具有的操作权限。连接层包括`连接器`和`连接池组件`，本文不对连接器做过多的介绍。

#### 连接池组件（Connection Pool)
  读者应该都知道，数据库中释放连接这个操作非常的消耗系统资源，所以我们要尽可能少的进行释放资源操作。连接池是维护数据库连接的缓存，以便在将来对数据库的请求时可以重用连接。 连接池用于增强对数据库执行的命令的性能。为每个用户打开和维护数据库连接，特别是对动态数据库驱动的网站应用程序的请求，是昂贵的并且浪费资源。在连接池中，在创建连接之后，将其放置在池中并再次使用它，便无需建立新连接。如果正在使用所有连接，则会建立新连接并将其添加到池中。 连接池还减少了用户必须等待建立与数据库的连接的时间。
  
  
 2.**服务层**  
 第二层服务层主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，sql的分析和优化以及部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。在服务层，服务器会解析查询并创建相应的内部解析树，并对其进行相应的优化，如确定查询表的顺序，是否利用索引等。最后生成相应的执行操作，如果是`select`语句的话，服务器还会去查询内部的缓存。服务层主要包括着`企业级管理服务和工具组件` 、 `SQL 接口组建`、`查询分析器组件`、`优化器组件`、`缓冲组件`。
 
#### 企业级管理服务和工具组件（Enterprise Management Services &  Utilities)
服务管理和控制组件，主要用来回滚操作、恢复数据、数据的复制、迁移、元数据的管理等。

#### SQL 接口组建（SQL Interface)
各种SQL接口，用来接受用户的SQL命令，并且调用下面的解析器来解析SQL，并接受返回的用户需要查询的结果。
#### 查询分析器组件（Parser）
SQL命令传递到解析器的时候会被解析器进行验证和解析，查询分析组件会判断这一条sql语句执行的是什么操作，并将其转换为MySQL可以理解的操作语句（query translation），以及对于权限的判断，比如说DBA设定了普通用户不能访问某个数据库，那么当普通用户试图访问某个数据库的时候就会进行拦截（Object Privilege），这里的权限判断相对于连接层所进行的权限更加细化。**此处结论未必准确，后期必须在官方文档中找到确定结论才可删除此句话**

#### 优化器组件（Optimizer）
MySQL发展这么多年，已经非常的高效，内部具有自己的优化器组件，当sql语句经过前面的查询分析器的处理转化为MySQL可以理解的语句之后，MySQL内部对其进行了相关的优化，将其改为MySQL自己认为最优的执行顺序（并不一定是程序员或者DBA觉得最优的执行顺序）比如一条sql语句我们书写时的顺序是①②③④，在经过优化器组件时，可能会将其顺序改写为②④③①。我们在一些特殊的情况可能会加上一些强制索引来保证sql按照我们想要的情况来进行执行。在一些极端的情况，一些技术非常厉害的公司如阿里巴巴，他们甚至会移除掉该优化器组件，以减少sql所需要的处理时间。

#### 缓冲组件（Caches&Buffer）
缓冲组件,其作为全局的和各个引擎所独特的缓冲区域，缓冲区域的大小对数据的存取由较大的影响。

3.**引擎层**

存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有的功能不同。引擎层主要包括`可插拔存储引擎`。在MySQL官方对其的介绍中，有这么一句话：
  和其他的数据库相比，MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥良好作用，主要体现在`存储引擎的架构上`，插件式的存储引擎架构查询处理和其他的系统任务以及数据的存储提取相分离。

#### 可插拔存储引擎（Pluggable Storage Engines）
可插拔的存储引擎作为MySQL数据库体系结构的第三层--引擎层，在不同的环境下可以使用不同的数据库存储组件进行数据的存储，这样做的好处是什么呢？比方说我们是一个酷爱旅行的人，对于不同的地方对汽车的性能有着不同的要求，去俄罗斯的时候需要汽车的耐寒性能非常好，去泰国的时候需要汽车有较强的耐高温能力，其他的环境如沙漠，草原对于汽车的性能要求也各不相同。如果我们有钱的话，那么可以对于不同的地方买不同类型的汽车。但是如果无法那么做怎么办呢？可以通过更换汽车的引擎的方式和轮胎等组件的方式来获取我们想要的性能。对于MySQL来说道理是类似的，MySQL通过实现存储引擎的可插拔使得我们可以根据不同的情况选用不同的存储引擎。虽然在绝大多数的情况下使用innoDB就已经足够了。

4.**存储层**

数据存储层，主要是将数据存储运行于裸设备的文件系统之上，并完成与存储引擎的交互，存储层包括`File&Logs`。

#### 文件系统中的存储数据（File&Logs）

文件存储层作为MySQL数据库体系结构的第四层，和操作系统的文件系统进行交互，用来存储数据库中的数据和日志文件等。


## 数据的存储
在整个数据库体系结构中，我们可以使用不同的存储引擎来存储数据，而绝大多数存储引擎都以二进制的形式存储数据；这一节会介绍 InnoDB 中对数据是如何存储的。

在 InnoDB 存储引擎中，所有的数据都被**逻辑地**存放在表空间中。表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）：

![imagepng](http://piv1n6e1j.bkt.clouddn.com//file/2018/11/f9e6b1f91c9846f190c3e0011126250b_image.png) 

同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 `innodb_page_size` 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同：

![](https://raw.githubusercontent.com/Draveness/Analyze/master/contents/Database/images/mysql/Relation%20Between%20Page%20Size%20-%20Extent%20Size.png)

从图中可以看出，在 InnoDB 存储引擎中，一个区的大小最小为 1MB，页的数量最少为 64 个。

### 如何存储表

MySQL 使用 InnoDB 存储表时，会将**表的定义**和**数据索引**等信息分开存储。其中前者存储在 `.frm` 文件中，后者存储在 `.ibd` 文件中，这一节就会对这两种不同的文件分别进行介绍。

![imagepng](http://piv1n6e1j.bkt.clouddn.com//file/2018/11/1a35b38976f340d68edafdd80c57b1a5_image.png) 



#### .frm 文件

无论你选择哪种存储引擎，你创建的每个MySQL表都会在磁盘上由`.frm`描述表格格式的文件（即表定义）表示。该文件与表名相同，带有 `.frm`扩展名。`.frm` 所有平台上的格式都相同。

```
CREATE TABLE test_frm(
    name CHAR(5),
    age INTEGER
);

```

当我们使用上面的代码创建表时，会在磁盘上的 `datadir` 文件夹中生成一个 `test_frm.frm` 的文件，这个文件中就包含了表结构相关的信息：
该datadir 位置可以通过**SHOW VARIABLES LIKE 'datadir'** 命令来获取。

```
[root@izwz9i3oc10rtcqy9277xtz test]# cd /var/lib/mysql/test
[root@izwz9i3oc10rtcqy9277xtz test]# ls
db.opt  test_frm.frm  test_frm.ibd
[root@izwz9i3oc10rtcqy9277xtz test]#  hexdump -v -C test_frm.frm
00000000  fe 01 09 0c 03 00 00 10  01 00 00 30 00 00 10 00  |...........0....|
···
00001010  ff 20 20 20 20 20 00 00  00 00 00 00 06 00 49 6e  |.     ........In|
00001020  6e 6f 44 42 00 00 00 00  00 00 0b 00 00 00 00 00  |noDB............|
···
000020a0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000020b0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000020c0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000020d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000020e0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
000020f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00002100  01 00 02 00 3f 00 10 00  00 00 0a 00 0b 00 00 00  |....?...........|
00002110  00 00 00 00 00 00 50 00  16 00 02 00 00 00 00 00  |......P.........|
00002120  3f 00 03 02 02 14 29 20  20 20 20 20 20 20 20 20  |?.....)         |
00002130  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 20  |                |
00002140  20 20 20 20 20 20 20 20  20 20 20 20 20 20 20 00  |               .|
00002150  04 00 05 6e 61 6d 65 00  05 00 04 61 67 65 00 04  |...name....age..|
00002160  05 05 05 00 02 00 00 00  80 00 00 00 fe 08 00 00  |................|
00002170  05 04 0b 0b 00 07 00 00  1b 80 00 00 00 03 08 00  |................|
00002180  00 ff 6e 61 6d 65 ff 61  67 65 ff 00              |..name.age..|
0000218c

```

> MySQL 官方文档中的 [11.1 MySQL .frm File Format](https://dev.mysql.com/doc/internals/en/frm-file-format.html) 一文对于 `.frm` 文件格式中的二进制的内容有着非常详细的表述，在这里就不展开介绍了。

#### .ibd 文件

InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 `ibdata1`、`ibdata2` 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。另一个就是每个表所独有的存储空间，当打开 `innodb_file_per_table` 选项时，`.ibd` 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。

### 如何存储记录

与现有的大多数存储引擎一样，InnoDB 使用页作为磁盘管理的最小单位；数据在 InnoDB 存储引擎中都是按行存储的，每个 16KB 大小的页中可以存放 2-200 行的记录。

当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：

![imagepng](http://piv1n6e1j.bkt.clouddn.com//file/2018/11/fe006fb7537b4eb79de32cfeea9ea517_image.png) 



> Antelope 是 InnoDB 最开始支持的文件格式，它包含两种行格式 Compact 和 Redundant，它最开始并没有名字；Antelope 的名字是在新的文件格式 Barracuda 出现后才起的，Barracuda 的出现引入了两种新的行格式 Compressed 和 Dynamic；InnoDB 对于文件格式都会向前兼容，而官方文档中也对之后会出现的新文件格式预先定义好了名字：Cheetah、Dragon、Elk 等等。

两种行记录格式 Compact 和 Redundant 在磁盘上按照以下方式存储：
![imagepng](http://piv1n6e1j.bkt.clouddn.com//file/2018/11/1d8052e0f76947528262cdfb5e2ea71b_image.png) 



Compact 和 Redundant 格式最大的不同就是记录格式的第一个部分；在 Compact 中，行记录的第一部分倒序存放了一行数据中列的长度（Length），而 Redundant 中存的是每一列的偏移量（Offset），从总体上上看，Compact 行记录格式相比 Redundant 格式能够减少 20% 的存储空间。

#### 行溢出数据

当 InnoDB 使用 Compact 或者 Redundant 格式存储极长的 VARCHAR 或者 BLOB 这类大对象时，我们并不会直接将所有的内容都存放在数据页节点中，而是将行数据中的前 768 个字节存储在数据页中，后面会通过偏移量指向溢出页。



但是当我们使用新的行记录格式 Compressed 或者 Dynamic 时都只会在行记录中保存 20 个字节的指针，实际的数据都会存放在溢出页面中。


当然在实际存储中，可能会对不同长度的 TEXT 和 BLOB 列进行优化，不过这就不是本文关注的重点了。

> 想要了解更多与 InnoDB 存储引擎中记录的数据格式的相关信息，可以阅读 [InnoDB Record Structure](https://dev.mysql.com/doc/internals/en/innodb-record-structure.html)

### 数据页结构

页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面，我们在这里将要介绍页是如何组织和存储记录的；首先，一个 InnoDB 页有以下七个部分：



每一个页中包含了两对 header/trailer：内部的 Page Header/Page Directory 关心的是页的状态信息，而 Fil Header/Fil Trailer 关心的是记录页的头信息。

在页的头部和尾部之间就是用户记录和空闲空间了，每一个数据页中都包含 Infimum 和 Supremum 这两个**虚拟**的记录（可以理解为占位符），Infimum 记录是比该页中任何主键值都要小的值，Supremum 是该页中的最大值：


User Records 就是整个页面中真正用于存放行记录的部分，而 Free Space 就是空余空间了，它是一个链表的数据结构，为了保证插入和删除的效率，整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入，行记录在物理存储上并不是按照顺序的，它们之间的顺序是由 `next_record` 这一指针控制的。

B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 `n_owned`、`next_record` 属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。

InnoDB 存储引擎中对数据的存储是一个非常复杂的话题，这一节中也只是对表、行记录以及页面的存储进行一定的分析和介绍，虽然作者相信这部分知识对于大部分开发者已经足够了，但是想要真正消化这部分内容还需要很多的努力和实践。


## 参考

*   [File Space Management](https://dev.mysql.com/doc/refman/5.7/en/innodb-file-space.html)
*   [MySQL .frm File Format](https://dev.mysql.com/doc/internals/en/frm-file-format.html)
*   [Externally Stored Fields in InnoDB](http://mysqlserverteam.com/externally-stored-fields-in-innodb/)
*   [InnoDB Record Structure](https://dev.mysql.com/doc/internals/en/innodb-record-structure.html)
*   [InnoDB Page Structure](https://dev.mysql.com/doc/internals/en/innodb-page-structure.html)


## 小结

在上文中，主要对MySQL的整体框架和数据的存储有了一个大致的介绍，在接下来的文章中，会深入MySQL的各个部件，在平时的工作中，我们也要学会将问题分类到所属的层次，并根据所属层次排查和解决问题。



















