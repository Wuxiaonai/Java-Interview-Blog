![](https://img.hacpai.com/bing/20171211.jpg?imageView2/1/w/960/h/520/interlace/1/q/100)

# MySQL解密系列（三）-- 深入分析InnoDB引擎的事务

## 前言
   在这一系列的文章中，如果不加说明，默认指的是innoDB引擎。本文作为MySQL解密系列的第三篇,主要讲一下InnoDB引擎中的事务。

## 什么是事务
  首先要知道的是，什么是事务。
  一个数据库事务通常包含了一个系列的对数据库的读/写操作。它的存在包含有以下两个目的：
  
* 为数据库系列操作提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。
* 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。

  当事务被提交给了DBMS（数据库管理系统），则DBMS（数据库管理系统）需要确保该事务中的所有操作都成功完成,并把结果被永久保存在数据库中。如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态;同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。

  但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。
  
  并非任意的对数据库的操作序列都是数据库事务。数据库事务拥有以下四个特性，习惯上被称之为ACID特性。

* 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。原子性是指整个原子性事务是不可分割得工作单元，只有当事务中所有的数据库操作都执行成功，才算整个事务成功，事务中任何一个SQL语句执行失败，已经执行成功的SQL语句也必须撤销，数据库状态应该退回到执行事务前的状态。举例说一个转账操作，任何一个步骤执行出错，都要恢复到初始状态。
* 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。比如说，在表中有一个字段是姓名，它作为一个唯一约束（表中不允许有重复的姓名），如果一个事务对姓名这个字段做出了修改的话，那么就破坏了一致性，系统可能会自动撤销事务。
* 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。
* 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。持久性保证的是是事务系统的高可靠性。

## innoDB中的事务实现

### 什么是undo、redo、binlog日志
  数据库存放数据的文件为data file，数据库中的内容在内存里是有缓存的，也就是db buffer。某次操作，我们取了数据库某表格中的数据，这个数据会在内存中缓存一些时间。对这个数据的修改在开始时候也只是修改在内存中的内容。当db buffer已满或者遇到其他的情况，这些数据会写入data file。日志文件在内存里也是有缓存的，称其为log buffer。磁盘上的日志文件称为log file。log file一般是追加内容，也就是是顺序写，顺序写的磁盘IO开销要远小于随机写。
 
  `undo log`记录某数据被修改前的值，可以用来在事务失败时进行rollback；`redo log`记录某数据块被修改后的值，可以用来恢复未写入data file的已成功事务更新的数据。`binlog`是二进制格式的日志文件，用来记录Mysql内部对数据库的改动（只记录对数据的修改操作），主要用于数据库的主从复制以及增量恢复。binlog有两种模式，`statement模式`是记录sql语句， `row模式`是记录行的内容，记两条数据，分别是数据更新前和数据更新后的内容。

  MySQL是通过锁来保证数据库事务的隔离性，在本文不进行过多的介绍。MySQL是通过WAL方式，来保证数据库事务的一致性和持久性，即ACID特性中的C(consistent)和D(durability)。

WAL（Write-Ahead Logging）是一种实现事务日志的标准方法，具体而言就是:

* 修改记录前，一定要先写日志；

* 事务提交过程中，一定要保证日志先落盘，才能算事务提交完成。

通过WAL方式，在保证事务特性的情况下，可以提高数据库的性能。

提交过程中，主要做了4件事情：

1. 清理undo段信息，对于innodb存储引擎的更新操作来说，undo段需要purge，这里的purge主要职能是，真正删除物理记录。在执行delete或update操作时，实际旧记录没有真正删除，只是在记录上打了一个标记，而是在事务提交后，purge线程真正删除，释放物理页空间。因此，提交过程中会将undo信息加入purge列表，供purge线程处理。

2. 释放锁资源，mysql通过锁互斥机制保证不同事务不同时操作一条记录，事务执行后才会真正释放所有锁资源，并唤醒等待其锁资源的其他事务；

3. 刷redo日志，前面我们说到，mysql实现事务一致性和持久性的机制。通过redo日志落盘操作，保证了即使修改的数据页没有及时更新到磁盘，只要日志是完成了，就能保证数据库的完整性和一致性；

4. 清理保存点列表，每个语句实际都会有一个savepoint(保存点)，保存点作用是为了可以回滚到事务的任何一个语句执行前的状态，由于事务都已经提交了，所以保存点列表可以被清理了。

MySQL 本身不提供事务支持，而是开放了存储引擎接口，由具体的存储引擎来实现，具体来说最常用的支持 MySQL 事务的存储引擎就是 InnoDB。

存储引擎实现事务的通用方式是基于 redo log 和 undo log。

前面已经说过，redo log 是用来记录事务修改后的数据, undo log是用来记录事务执行前的原始数据。

所以当一个事务执行时实际发生过程简化描述如下：

1.  先记录 undo/redo log，确保日志刷到磁盘上持久存储。
2.  更新数据记录，缓存操作并异步刷盘。
3.  提交事务，在 redo log 中写入 commit 记录。

在 MySQL 执行事务过程中如果因故障中断，可以通过 redo log 来重做事务或通过 undo log 来回滚，确保了数据的一致性。


都是由事务性存储引擎来完成的，但 binlog 不在事务存储引擎范围内，而是由 MySQL Server 来记录的。

那么就必须保证 binlog 数据和 redo log 之间的一致性，所以开启了 binlog 后实际的事务执行就多了一步，如下：

1.  先记录 undo/redo log，确保日志刷到磁盘上持久存储。
2.  更新数据记录，缓存操作并异步刷盘。
3.  将事务日志持久化到 binlog。
4.  提交事务，在 redo log 中写入commit记录。
<htnl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</html>![imagepng](http://qiniuyun.indispensable.cn//file/2018/11/985eae844b274c7e8d33a2025c7c36a3_image.png) 
可能有读者会感觉到疑惑，为什么没有进行写入data file,事务就这样提交了？其实在数据库中，可以这么说--有了日志就有了一切。并且日志是顺序写，而写入data file是随机写，顺序写的性能优于随机写。
由于需要保持binlog和redo log的一致性，只要 binlog 没写成功，整个事务是需要回滚的，而 binlog 写成功后即使 MySQL Crash 了都可以恢复事务并完成提交。

在这里对发生冲突的解决做一个简单的分析：
<htnl>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</html>![imagepng](http://qiniuyun.indispensable.cn//file/2018/11/5c7ec51ac7ca49cd9cd429b0f2be9fbb_image.png) 
   1. 当在写入bin log 之前系统出现错误或者崩溃时,重启恢复后发现没有commit，使用undo/redo log回滚事务，此时没有binlog。binlog 和redolog保持了一致。
	2. 当在commit之前系统出现错误或者崩溃，重启恢复后发现虽没有commit，但满足prepare阶段写入的redo日志和binlog都完整，所以重启后会自动commit。此时有binlog， binlog 和redolog保持了一致。


要做到这点，就需要把 binlog 和事务关联起来，而只有保证了 binlog 和事务数据的一致性，才能保证主从数据的一致性。

所以 binlog 的写入过程不得不嵌入到事务存储引擎的执行过程中，并以内部分布式事务（xa 事务）的方式完成两阶段提交。

上面的内容大致向读者朋友们介绍了什么是undo log、redo log和bin log,在极客时间的MySQL课程中，举了一个关于redo log的例子，在这里拿出来辅助一下大家的理解：
>
 在《孔乙己》这篇文章中，酒店掌柜有一个粉板，专门用来记录客户的赊账记录。如果赊账的不多，那么他可以把顾客名和账目写在板上。但如果赊账的人多了，粉板总会有记不下的时候，这个时候掌柜一定还有一个专门记录赊账的账本。
  如果有人要赊账或者还账的话，掌柜一般有两种做法：
1.  一种做法是直接把账本翻出来，把这次赊的账加上去或者扣除掉；
2.  另一种做法是先在粉板上记下这次的账，等打烊以后再把账本翻出来核算。
  在生意红火柜台很忙时，掌柜一定会选择后者，因为前者操作实在是太麻烦了。首先，你得找到这个人的赊账总额那条记录。你想想，密密麻麻几十页，掌柜要找到那个名字，可能还得带上老花镜慢慢找，找到之后再拿出算盘计算，最后再将结果写回到账本上。这整个过程想想都麻烦。
  相比之下，还是先在粉板上记一下方便。你想想，如果掌柜没有粉板的帮助，每次记账都得翻账本，效率是不是低得让人难以忍受？
  同样，在 MySQL 里也有这个问题，如果每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了类似酒店掌柜粉板的思路来提升更新效率。
  具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，这个时候更新就算完成了。
  同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事。
  如果今天赊账的不多，掌柜可以等打烊后再整理。但如果某天赊账的特别多，粉板写满了，又怎么办呢？这个时候掌柜只好放下手中的活儿，把粉板中的一部分赊账记录更新到账本中，然后把这些记录从粉板上擦掉，为记新账腾出空间。


## innoDB中的两阶段提交

### 什么是两阶段提交
  在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足事务所需要的ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该commit还是 roolback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。
  2PC顾名思义分为两个阶段进行提交，其实施思路可概括为：
1. 投票阶段（voting phase）：参与者将操作结果通知协调者；
2. 提交阶段（commit phase）：收到参与者的通知后，协调者再向参与者发出通知，根据反馈情况决定各参与者是否要提交还是回滚；
  上面的偏向于官方的说法，读者可能无法快速进行理解，这里举一个实际的案例做一下说明：
		 <html>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</html> ![imagepng](http://qiniuyun.indispensable.cn//file/2018/11/b40f3031312b40ae8751a88af9414685_image.png) 
  当我们将支付宝的余额转账100块钱到余额宝中去，那么这个过程可以分为以下两个操作：
  
  1. 从支付宝的余额扣除100元
  2. 将余额宝中的余额增加100元
  
  那么我们怎么来实现这个事情呢？有人肯定会说，这个操作非常简单啊，只要使用事务就可以了。如果余额宝的数据库和支付宝余额的数据库位于同一个数据库的实例里面，那么这个事务就可以成功的执行，但是实际上不可能放在同一个数据库实例上，因为系统的规模较大时就会采用分布式，数据库往往位于不同的物理节点上面。这个时候，使用常规的本地事务就没有任何作用，那就需要使用到分布式事务。
![imagepng](http://qiniuyun.indispensable.cn//file/2018/11/582524d9014443f7bad97e68a49ceb36_image.png) 

 
* 首先，当我们发起一个转账100元的请求时，将发送一个请求到TC（事务协调器），协调器来保证分布式事务的执行。
* TC先将`prepare`消息写到本地日志，之后向所有的参与者发起消息。以支付宝转账到余额宝为例，TC给参与者A的`prepare`消息是通知支付宝数据库相应账目扣款100，TC给参与者B的`prepare`消息是通知余额宝数据库相应账目增加100。为什么在执行任务前需要先写本地日志，主要是为了故障后恢复用，本地日志起到现实生活中凭证的效果，如果没有本地日志（凭证），出问题容易死无对证；
* 参与者收到消息后，执行具体本机事务，但不会进行commit，如果成功返回`yes`，不成功返回`no`。同理，返回前都应把要返回的消息写到日志里，当作凭证。
* TC收集所有参与者返回的消息，如果所有参与者`都返回yes`，那么给所有参与者发送`commit`消息，参与者收到commit后执行本地事务的commit操作；如果有`任一个参与者返回no`，那么给所有参与者发送`abort`消息，参与者收到abort消息后执行事务abort操作(等同于rollback操作)。
* 参与者执行完commit/abort后应该发送ack给事务协调器，如果超时未发送，事务协调器会再次发出commit/abort请求。

注：TC或参与者把发送或接收到的消息先写到日志里，主要是为了故障后恢复用。如某一参与者从故障中恢复后，先检查本机的日志，如果已收到`commit`，则提交，如果`abort`则回滚。如果发现日志中记录的为给TC发送`yes`消息，则再向TC询问一下，确定下一步。如果什么都没有，则很可能在`prepare`阶段参与者就已经发生故障了，因此需要根据本机的undo/redo日志回滚数据。

### 两阶段提交算法实现


### 两阶段提交算法的缺点
两阶段提交看着好像挺不错的样子，然而在具体的使用中有`很大的缺点`。
1. **效率低** 算法在执行过程,所有的节点都处于阻塞状态，所有节点所持有的资源（例如数据库数据，本地文件等）都无法被其他线程使用。如果其中一个参与者长时间无法做出回应，那么就需要消耗大量时间做出等待。
2.**通信时间长** 两阶段提交涉及多次节点间的网络通信，通信所花费的时间太长了。
3. **单点故障** 由于事务协调器(TC)的重要性，一旦TC发生故障。参与者会一直阻塞下去。尤其在第二阶段，TC发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是TC挂掉，可以重新选举一个TC，但是无法解决因为TC宕机导致的参与者处于阻塞状态的问题）
4. **数据不一致** 在二阶段提交的阶段二中，当事务协调器(TC)向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中TC发生了故障，这会导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。
5. **二阶段无法解决的问题** 如果事务协调器(TC)在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使事务协调器通过选举协议产生了新的事务协调器，这条事务的状态也是不确定的，没人知道事务是否被已经提交。


### 什么是三阶段提交


### 为什么innodb使用两阶段提交


### 两阶段提交小结
  两阶段提交算法的实现大致就是上述的内容，将分布式的事务分为投票和提交两个阶段进行，投票阶段事务协调器给每个参与者发送prepare消息，每个参与者要么直接返回失败(如权限验证失败)，要么在本地执行事务，写本地的redo和undo日志，但并不进行commit操作。此阶段结束每个返回ok的节点都应该达到除了commit其余全都完成的状态。提交阶段时，如果事务协调器收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(abort)消息；否则，发送commit消息；参与者根据事务协调器的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。
  但是由于2pc算法的种种缺点，所以在实际的生产环境中，我们一般不会使用2pc算法。可以使用比如消息队列来避免分布式事务，在本文中不做过多介绍，感兴趣的读者朋友可以自己搜索一下相关资料。


## 总结
  在本文中，我们先说了一下什么是事务，然后再对2pc进行了解说和举例，但是在本文中对于事务的级别并未作出说明，后续如果有需要可能会对这一块做出介绍。本文尚未完全完成，比如说对2pc算法的详细说明以及3pc算法的介绍，将会在下一次更新中做出更详细的介绍。

## 参考

* [Transaction processing -- Wikipedia](https://en.wikipedia.org/wiki/Transaction_processing)
* [hollischuang -- 关于分布式事务、两阶段提交协议、三阶提交协议](https://www.hollischuang.com/archives/681)
* [峰云就她了--理解分布式事务的两阶段提交2pc](http://xiaorui.cc/2016/02/25/%E7%90%86%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A42pc/)
